<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="区块链,hyperledger,fabric," />





  <link rel="alternate" href="/atom.xml" title="mosen" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="参考资料来源 源码在fabric源码中实现 fabric 功能的核心代码，包括：  •    accesscontrol 包：实现对 chaincode 的权限管理和属性校验等； •    common 包：一些通用的模块； •    core 包：大部分核心实现代码都在本包下。其它包的代码封装上层接口，最终调用本包内代码； •    events 包：支持 event 框架； •    exam">
<meta name="keywords" content="区块链,hyperledger,fabric">
<meta property="og:type" content="article">
<meta property="og:title" content="我对hyperledger fabric 1.0 架构的理解">
<meta property="og:url" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/index.html">
<meta property="og:site_name" content="mosen">
<meta property="og:description" content="参考资料来源 源码在fabric源码中实现 fabric 功能的核心代码，包括：  •    accesscontrol 包：实现对 chaincode 的权限管理和属性校验等； •    common 包：一些通用的模块； •    core 包：大部分核心实现代码都在本包下。其它包的代码封装上层接口，最终调用本包内代码； •    events 包：支持 event 框架； •    exam">
<meta property="og:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/jiagou.png">
<meta property="og:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/membership1.png">
<meta property="og:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/membership2.png">
<meta property="og:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/chaincode.png">
<meta property="og:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/cunchu.png">
<meta property="og:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/filesystem.png">
<meta property="og:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/merkle.png">
<meta property="og:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/0.6.png">
<meta property="og:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/0.6arc.png">
<meta property="og:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/1.0arc.png">
<meta property="og:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/channel.png">
<meta property="og:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/channel_join.png">
<meta property="og:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/channel_trans.png">
<meta property="og:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/transmision.png">
<meta property="og:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/transmision_me.png">
<meta property="og:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/org.png">
<meta property="og:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/checkpoint.png">
<meta property="og:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/checkpoint_me.png">
<meta property="og:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/endorser.png">
<meta property="og:updated_time" content="2017-04-22T09:01:59.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="我对hyperledger fabric 1.0 架构的理解">
<meta name="twitter:description" content="参考资料来源 源码在fabric源码中实现 fabric 功能的核心代码，包括：  •    accesscontrol 包：实现对 chaincode 的权限管理和属性校验等； •    common 包：一些通用的模块； •    core 包：大部分核心实现代码都在本包下。其它包的代码封装上层接口，最终调用本包内代码； •    events 包：支持 event 框架； •    exam">
<meta name="twitter:image" content="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/jiagou.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/"/>





  <title> 我对hyperledger fabric 1.0 架构的理解 | mosen </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mosen</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-nodejs">
          <a href="/Nodejs" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-folder-open"></i> <br />
            
            Nodejs
          </a>
        </li>
      
        
        <li class="menu-item menu-item-react">
          <a href="/React" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-folder-open"></i> <br />
            
            React
          </a>
        </li>
      
        
        <li class="menu-item menu-item-js">
          <a href="/Js" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-folder-open"></i> <br />
            
            Js
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-search">
          <a href="/search" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-search"></i> <br />
            
            搜索
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://huangmxsysu.github.io/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mosen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mosen">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                我对hyperledger fabric 1.0 架构的理解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-22T11:04:34+08:00">
                2017-04-22
              </time>
            

            

            
          </span>
          


          
             <span id="busuanzi_container_page_pv">&nbsp;&nbsp;|&nbsp;&nbsp;阅读量 <span id="busuanzi_value_page_pv"></span> 次</span>
          



          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="参考资料来源"><a href="#参考资料来源" class="headerlink" title="参考资料来源"></a>参考资料来源</h4><ul>
<li><a href="https://github.com/hyperledger/fabric" target="_blank" rel="external">源码</a><br><hr><br>在fabric源码中实现 fabric 功能的核心代码，包括：</li>
</ul>
<p>•    <code>accesscontrol</code> 包：实现对 chaincode 的权限管理和属性校验等；</p>
<p>•    <code>common</code> 包：一些通用的模块；</p>
<p>•    <code>core</code> 包：大部分核心实现代码都在本包下。其它包的代码封装上层接口，最终调用本包内代码；</p>
<p>•    <code>events</code> 包：支持 event 框架；</p>
<p>•    <code>examples</code> 包：包括一些示例的 chaincode 代码；</p>
<p>•    <code>flogging</code> 包：封装 go-logging，提供日志支持；</p>
<p>•    <code>gossip</code> 包：实现 gossip 协议；</p>
<p>•    <code>metadata</code> 包：版本信息等；</p>
<p>•    <code>msp</code>包：Member Service Provider 包；</p>
<p>•    <code>order</code> 包：order 服务相关的入口和框架代码；</p>
<p>•    <code>peer</code> 包：peer 的入口和框架代码；</p>
<p>•    <code>protos</code> 包：包括各种协议和消息的 protobuf 定义文件；</p>
<hr>

<ul>
<li><p><a href="http://hyperledger-fabric.readthedocs.io/en/latest/FAQ/architecture_FAQ.html" target="_blank" rel="external">fabric1.0官方文档</a></p>
</li>
<li><p><a href="https://github.com/hyperledger-archives/fabric/blob/master/docs/protocol-spec.md?cm_mc_uid=86231266818714891311835&amp;cm_mc_sid_50200000=1492157047&amp;cm_mc_sid_52640000=1492157047" target="_blank" rel="external">fabric协议（这是0.6版本的协议，但是里面可以参考的有很多，建议整个文档读下来)</a></p>
</li>
<li><p><a href="https://github.com/hyperledger-archives/fabric/tree/master/docs" target="_blank" rel="external">还有这个文件目录下的各个文件夹中的readme.md文件</a></p>
</li>
<li><p><a href="https://www.ibm.com/developerworks/cloud/library/cl-top-technical-advantages-of-hyperledger-fabric-for-blockchain-networks/index.html" target="_blank" rel="external">fabric1.0优点详解</a></p>
</li>
<li><p><a href="https://docs.google.com/document/d/1vNMaM7XhOlu9tB_10dKnlrhy5d7b1u8lSY8a-kVjCO4/edit" target="_blank" rel="external">基于kafka的共识服务的详细的一个介绍</a></p>
</li>
<li><p><a href="https://github.com/hyperledger/fabric/blob/master/docs/source/arch-deep-dive.rst" target="_blank" rel="external">关于fabric1.0交易流程说明（当然在官方文档中也有）</a></p>
</li>
<li><p><a href="https://yeasy.gitbooks.io/blockchain_guide/distribute_system/bft.html" target="_blank" rel="external">区块链指南</a></p>
</li>
</ul>
<ul>
<li><p><a href="https://www.altoros.com/blog/tag/hyperledger/" target="_blank" rel="external">一个介绍类的栏目吧，有时候会有hyperledger相关的文章</a></p>
</li>
<li><p><a href="https://chat.hyperledger.org/" target="_blank" rel="external">一个像stackoverflow一样的小型的交流问题的地方，可以申请个账号，提一些问题之类的</a></p>
</li>
<li><p><a href="https://www.youtube.com/watch?v=s_EEIabtsao" target="_blank" rel="external">hyperledger在youtube上的专栏视频吧，视频一般很短，但是听下来能借鉴很多东西（也可以提高下英语听力）</a></p>
</li>
<li><p><a href="https://wn.com/1_hyperledger_fabric_build" target="_blank" rel="external">wn.com上的技术介绍视频</a></p>
</li>
<li><p><a href="http://www.econotimes.com/" target="_blank" rel="external">一个信息比较及时的关于新技术的新闻网站吧</a></p>
</li>
<li><p><a href="https://www.ibm.com/developerworks/community/blogs/3302cc3b-074e-44da-90b1-5055f1dc0d9c?tags=blockchain&amp;lang=zh" target="_blank" rel="external">IBM中文社区一个微讲堂系列，里面的视频一般要一个小时，不过有用，不过最近由于优酷视频出现用户信息泄露事件，所以应该看不了现在。</a></p>
</li>
<li><p><a href="http://8btc.com/doc-view-605.html" target="_blank" rel="external">Hyperledger白皮书</a></p>
</li>
<li><p><a href="https://www.ibm.com/developerworks/cn/cloud/library/cl-blockchain-basics-intro-bluemix-trs/" target="_blank" rel="external">区块链技术基础：分布式账本简介</a></p>
</li>
</ul>
<h3 id="fabric-架构图"><a href="#fabric-架构图" class="headerlink" title="fabric 架构图"></a><div align="center">fabric 架构图</div></h3><p>&emsp;&emsp;hyperledger技术建立在原有区块链技术上，同时扩展了成员管理以及链码技术，构成了fabric的三大架构体系：Membership Services, Blockchain Services, Chaincode Services,如图所示是fabric0.6中的架构图：</p>
<div align="center"><br><img src="/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/jiagou.png" width="80%"><br></div>


<p><br><br><br></p>
<h3 id="Membership-Services（成员管理服务）"><a href="#Membership-Services（成员管理服务）" class="headerlink" title="Membership Services（成员管理服务）"></a><div align="center">Membership Services（成员管理服务）</div></h3><p>&emsp;&emsp;成员管理服务用来管理节点身份、隐私、confidentiality 和 auditability。在一个 non-permissioned的区块链网络里，参与者不要求授权，所有的节点被视作一样，都可以去submit一个transaction，去把这些交易存到区块（blocks）中。那Membership Service是要将一个 non-permissioned的区块链网络变成一个permissioned的区块链网络，凭借着Public Key Infrastructure (PKI)、去中心和一致性。    </p>
<p>&emsp;&emsp;Hyperledger是一个私人认证网络协议，因此所有个体都需要注册会员服务来获取身份，从而进行网络访问及交易。在网络设置过程中，验证器可以鉴定交易所需权限级别。网络设置过程也会设置权限，实现轻松访问、高速高效应用、或严格控制网络环境。</p>
<p>概括地解释：</p>
<ol>
<li>注册机制</li>
</ol>
<p>注册机制能够控制并管理Hyperledger参与者的权限。</p>
<ol>
<li>身份管理</li>
</ol>
<p>身份管理能够提供管理保障，根据Hyperledger参与者的身份与角色来授予信息披露权限。</p>
<ol>
<li>可审核性    </li>
</ol>
<p>可审核性能够帮助授权个体将个人或团体之间的交易连接起来，并且访问系统中某一用户的活动情况，或其本身的运行情况。</p>
<p>&emsp;&emsp;具体地，上面我们提到membership services成员服务，旨在通过身份管理协调交易隐私以及提供可审计的服务</p>
<ul>
<li>为交易添加证书来实现“有权限的”区块链</li>
</ul>
<ul>
<li><p>使用两层系统：</p>
<ul>
<li><p>向登记的证颁发机构（CA）注册来获得(相对的) 静态登记证书 (ECerts)</p>
</li>
<li><p>通过交易CA获取能如实但伪匿名的代表登记用户的交易证书(TCerts).</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>提供对系统中未授权会员隐藏交易内用的机制</li>
</ul>
<h4 id="fabric成员管理详细过程"><a href="#fabric成员管理详细过程" class="headerlink" title="fabric成员管理详细过程"></a><div align="center">fabric成员管理详细过程</div></h4><h6 id="fabric涉及到的PKI术语解释"><a href="#fabric涉及到的PKI术语解释" class="headerlink" title="fabric涉及到的PKI术语解释"></a>fabric涉及到的PKI术语解释</h6><p><br></p>
<table>
<thead>
<tr>
<th style="text-align:center">术语</th>
<th style="text-align:center">角色</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">根证书颁发机构(根CA)</td>
<td style="text-align:center">它代表PKI体系中的信任锚。数字证书的验证遵循信任链。根CA是PKI层次结构中最上层的CA</td>
</tr>
<tr>
<td style="text-align:center">登记机构(RA)</td>
<td style="text-align:center"><br>它是一个可以确定想要加入到带权限区块链的用户的有效性和身份的可信实体。它是负责与用户外的带外通信来验证他/她的身份和作用。它是负责与用户进行频外通信来验证他/她的身份和角色。它创建登记时所需要的注册证书和根信任上的信息。</td>
</tr>
<tr>
<td style="text-align:center">注册证书颁发机构(ECA)</td>
<td style="text-align:center">负责给通过提供的注册凭证验证的用户颁发注册证书(ECerts)</td>
</tr>
<tr>
<td style="text-align:center">交易认证中心(TCA)</td>
<td style="text-align:center">负责给提供了有效注册证书的用户颁发交易证书(TCerts)</td>
</tr>
<tr>
<td style="text-align:center">TLS证书颁发机构(TLS-CA)</td>
<td style="text-align:center">负责签发允许用户访问其网络的TLS证书和凭证。它验证用户提供的包含该用户的特定信息的，用来签发TLS证书的，证书或证据。</td>
</tr>
<tr>
<td style="text-align:center">注册证书(ECerts)</td>
<td style="text-align:center"><br>ECerts是长期证书。它们是颁发给所有角色的，如用户，非验证 peer，验证 peer。在给用户颁发的情况下，谁向区块链提交候选人申请谁就拥有TCerts</td>
</tr>
<tr>
<td style="text-align:center">交易证书(TCERTS)</td>
<td style="text-align:center"><br>TCerts是每个交易的短期证书。它们是由TCA根据授权的用户请求颁发的。它们安全的给一个交易授权，并可以被配置为隐藏谁参与了交易或选择性地暴露这样身份注册ID这样的信息。他们包含签名密钥对的公共部分，并可以被配置为包含一个密钥协议的密钥对的公共部分。</td>
</tr>
</tbody>
</table>
<p><br><br>&emsp;&emsp;成员管理服务是由网络上管理用户身份和隐私的几个基础架构来组成的。这些服务验证用户的身份，在系统中注册用户，并为他/她提供所有作为可用、兼容的参数者来创建和/或调用交易所需要的证书。</p>
<p>&emsp;&emsp;公告密钥体系（Public Key Infrastructure ，PKI）是一个基于不仅对公共网络上交换的数据的加密而且能确认对方身份的公共密钥加密的。PKI管理密钥和数字证书的生成，发布和废止。数字证书是用来建立用户证书，并对消息签名的。使用证书签名的消息保证信息不被篡改。典型的PKI有一个证书颁发机构（CA），一个登记机构（RA），一个证书数据库，一个证书的存储。</p>
<p>&emsp;&emsp;成员管理的这个实现提供下面描述的基础功能：ECerts是没有到期/废止的；TCert的过期是由验证周期的时间窗口提供的。TCerts是没有废止的。ECA，TCA和TLS CA证书是自签名的，其中TLS CA提供信任锚点。</p>
<h4 id="成员管理过程"><a href="#成员管理过程" class="headerlink" title="成员管理过程"></a><div align="center">成员管理过程</div></h4><p><br><br>&emsp;&emsp;在1.0版本中，membership service部分基本上是没有改变的，所以下面我们来看整一个成员管理的过程</p>
<div align="center"><br><img src="/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/membership1.png" width="80%"><br></div>

<div align="center"><em>备注：注册阶段图中我已经把过程详细放了进去，已经很详细了这里不做详细解释</em></div>

<div align="center"><br><img src="/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/membership2.png" width="80%"><br></div>

<p>&emsp;&emsp;说明一下上面的过程</p>
<ul>
<li><p>部署阶段：</p>
<p>  客户端: 请求TCert批量需要包含（另外计数），ECert和使用ECert私钥签名的请求（其中ECert的私钥使用本地存储获取的）, TCA为批量生成TCerts: 生成密钥派生函数的密钥，<code>KeyDF_Key</code>, 当作<code>HMAC(TCA_KDF_Key, EnrollPub_Key)</code>. 为每张TCert生成公钥(使用<code>TCertPub_Key = EnrollPub_Key + ExpansionValue</code>, 其中384位的<code>ExpansionValue = HMAC(Expansion_Key, TCertIndex)</code> 和384位的<code>Expansion_Key = HMAC(KeyDF_Key, “2”)</code>. 生成每个<code>AES_EncryptTCertOwner_EncryptKey(TCertIndex || 已知的填充/校验检查向量)</code>， 其中|| 表示连接，且<code>TCertOwner_EncryptKey</code>被当作<code>[HMAC(KeyDF_Key, “1”)]</code>派生256位截断.</p>
</li>
<li><p>调用查询阶段：</p>
<p>  客户端: 为调用和查询，根据TCert来生成TCert的私钥：<code>KeyDF_Key</code>和<code>ECert的私钥</code>需要从本地存储中获取。<code>KeyDF_Key</code>是用来派生被当作<code>[HMAC(KeyDF_Key, “1”)]</code>256位截断的<code>TCertOwner_EncryptKey</code>；<code>TCertOwner_EncryptKey</code>是用来对TCert中的 <code>AES_EncryptTCertOwner_EncryptKey(TCertIndex || 已知的填充/校验检查向量)</code>域解密的；<code>TCertIndex</code>是用来派生TCert的私钥的： <code>TCertPriv_Key = (EnrollPriv_Key + ExpansionValue)</code>模n，其中384位的<code>ExpansionValue = HMAC(Expansion_Key, TCertIndex)</code>，384位的<code>Expansion_Key = HMAC(KeyDF_Key, “2”)</code>。</p>
</li>
</ul>
<p><br></p>
<h3 id="Chaincode-Services（链码服务）"><a href="#Chaincode-Services（链码服务）" class="headerlink" title="Chaincode Services（链码服务）"></a><div align="center">Chaincode Services（链码服务）</div></h3><p><br></p>
<p>&emsp;&emsp;Chaincode services 会提供一种安全且轻量级的沙盒运行模式，来在VP节点上执行chaincode逻辑。这里使用Container环境，里面的base镜像都是经过签名验证的安全镜像，包括OS层和开发chaincode的语言、runtime和SDK层，目前支持Go、Jave和Nodejs开发语言。chaincode是一段应用级的代码，交易逻辑就在里面，fabric是用Docker容器来运行chaincode的。一旦chaincode容器被启动，它就会通过gRPC与启动这个chaincode的VP(Validating Peer)节点连接。</p>
<ul>
<li>安全容器</li>
</ul>
<p>&emsp;&emsp;链上代码服务使用<strong>Docker</strong>来存放链上代码( <code>build</code> , <code>start</code> , <code>stop</code> )，启动容器通过grpc传输协议与节点间进行通信。Docker为沙盒链上代码的执行提供了一个安全、轻便的方法。其环境是一个封锁又安全的容器，还有一套签署过的图片库，包括安全的操作系统及链上代码语言，以及<em>Golang</em>的SDK组图与执行环境。如果有需要的话，也能添加其他程序语言。</p>
<ul>
<li>链上代码交易</li>
</ul>
<p>&emsp;&emsp;链上代码交易是有时间限定的，并且在链上代码装置过程中是按特定形式装配的，这和数据库调用或网站服务调用类似。如果超过交易时限，那么就按出错处理，不会给账本状态带去任何改变。如果调用的函数有相同保密范围限制的话，一个链上代码函数就能够调用另一个链上代码函数–也就是说，如果两个机密链上代码之间，有相同的一组验证器，那么它们之间就能互相调用。</p>
<p>&emsp;&emsp;新区块进行交易时，会维持区块链上最后区块的整体状态差量。如果当前区块达到共识，那么变量就会提交到数据库，之后整体状态的区块数量就会增加1个。如果节点没有达到共识，那么差量就不会算入，数据库也不会进行修改。<br>构成链码代码交易的核心技术就是chaincode。对于一个区块链系统来说，区块链是由一个一个的区块串接而成，每个区块又是由若干的Transaction构成。所以，可以说Transaction是一个区块链系统中最基本的组成要素。而在Fabric中，Chaincode的运行是生成Transaction的唯一来源，也因此Chaincode是外界与Fabric区块链交互的唯一渠道。由此可见chaincode的重要性。</p>
<p>&emsp;&emsp;在fabric0.6版本中，chaincode需要实现三个函数，<code>Init</code>，<code>Invoke</code> 和 <code>Query</code>。Init是构造函数，它只在部署交易时被执行，Query函数用来读取状态。Invoke来进行交易的发生。chaincode容器被部署时，会向对应的peer进行注册，注册之后，VP节点就会通知chaincode容器调用Init函数。其实peer跟chaincode容器之间是隔着一个shim层的，chaincode容器的shim层会接收来自peer的信息，根据信息调用chaincode相应的函数，如Invoke。</p>
<p><strong>注：fabric1.0中把Query()函数整合到了Invoke()，所以新版本的函数只有两个，即Init(),Invoke()</strong></p>
<p><br><br>   下面，我根据官方github上的说明文档以及自己的理解解释下shim层的工作流程(shim层其实就是容器上的一个功能层)</p>
<p>   <br></p>
<div align="center"><br><img src="/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/chaincode.png" width="60%"><br></div>   


<p><br></p>
<h3 id="Blockchain-Services（区块链服务）"><a href="#Blockchain-Services（区块链服务）" class="headerlink" title="Blockchain Services（区块链服务）"></a><div align="center">Blockchain Services（区块链服务）</div></h3><p><br></p>
<p>&emsp;&emsp;Blockchain services使用建立在HTTP/2上的P2P协议来管理分布式账本。提供最有效的哈希算法来维护world state的副本。采取可插拔的方式来根据具体需求来设置共识协议，比如PBFT，Raft，PoW和PoS等等。</p>
<p><em>区块链服务由三个关键部分组成：分布式账本及存储，点对点（P2P）协议以及共识管理器。</em></p>
<p>概括地解释：</p>
<ul>
<li>(1) P2P协议</li>
</ul>
<p>P2P协议提供了很多功能，包括双向流，流量控制和多路复用。它构建于现有的互联网基础设施之上比如：防火墙、代理等，定义了节点和节点之间通讯的规则</p>
<ul>
<li>(2) 分布式账本及存储</li>
</ul>
<p>分布式账本管理区块链网络（可能是世界范围的）的交易的处理及验证工作，负责维护和更新区块链网络内所有对象的状态<br>一些基本的、非功能方面包括：</p>
<ul>
<li>高效的计算cryptographic hash</li>
<li>有效的计算差异，如果有节点数据没有更新，传输给它尽可能少的数据</li>
<li>保证每一次交易产生较少的数据（存储）</li>
</ul>
<p>分布式账本底层使用RocksDB，大文件的hash存储在链上，文件本身在链外存储</p>
<ul>
<li>(3) 共识机制管理</li>
</ul>
<p>共识机制管理为共识算法和其他组件之间定义了通用的接口，它接收交易，然后剩下的事情交给共识算法去做。共识机制管理使得共识算法模块化，可配置化。</p>
<p><br></p>
<h6 id="点对点（P2P）协议"><a href="#点对点（P2P）协议" class="headerlink" title="点对点（P2P）协议"></a>点对点（P2P）协议</h6><p>&emsp;&emsp;点对点协议运用的是Google RPC协议（谷歌远程过程调用协议，在超文本传输协议2.0标准下执行），其功能包括双向流、流控制、在单一连接下执行多路复用要求等。最重要的是，它能与现有网络基础设施结合，包括防火墙、代理服务器以及安全保护等。这一组合能够为对等节点采用的信息提供由点对点到多路传送的定义。</p>
<p><br></p>
<h6 id="分布式账本及数据存储"><a href="#分布式账本及数据存储" class="headerlink" title="分布式账本及数据存储"></a>分布式账本及数据存储</h6><p>&emsp;&emsp;下图是0.6版本协议中的一张图，不过大体上没有变化，1.0中只是增加了CouchDB（同样的k-v存储，只是能够支持负责的query）</p>
<div align="center"><br><img src="/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/cunchu.png" width="80%"><br></div> 

<p><br><br>&emsp;&emsp;整个区块结构分为文件系统存储的Block结构和数据库维护的State状态，其中state的存储结构是可以替换的，可选的实现包括各种KV数据库（如LEVELDB）</p>
<p>&emsp;&emsp;其中，hyperledger的文件系统（file system）是基于区块数据存储的HDFS文件存储结构。</p>
<p><br></p>
<div align="center"><br><img src="/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/filesystem.png" width="50%"><br></div> 

<p><br></p>
<p>&emsp;&emsp;<code>HDFS</code>可作为混合计算系统的文件管理系统，同时提供区块链存储空间和大数据存储空间。有关HDFS体系架构可参考很多资料，不做赘述，在此描述涉及到区块链存储的数据结构和术语：</p>
<table>
<thead>
<tr>
<th style="text-align:center">术语</th>
<th style="text-align:center">角色</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NameNode</td>
<td style="text-align:center"><br>HDFS集群的中心服务器<br>管理文件系统的Namespace元数据管理结点，一般由主NameNode和SecondNameNode组成(主NameNode的冷备份)。在混合计算系统的数据结构中，NameNode同时存放区块链分区表，用以管理区块链结点索引。与传统HDFS存储不同的是，区块链分区表由所有客户端共同维护，提供读写、查询区块位置<br><br></td>
</tr>
<tr>
<td style="text-align:center">DataNode</td>
<td style="text-align:center"><br>HDFS集群中的数据结点<br>管理数据存储。DataNode中一个数据块作为区块链中的一个区块存储空间(一一对应)。区块(Block)大小一般为1MB~20MB不等，小于HDFS一个数据块的大小(64MB或128MB)。但区块实际容量可以根据实际业务场景的需要，在社区内所有结点同意下进行扩容。在可预见的未来，HDFS现有数据块可以满足区块容量的要求<br><br></td>
</tr>
<tr>
<td style="text-align:center">BlockNode</td>
<td style="text-align:center"><br>区块链分区表结构<br>可以利用B-Tree索引实现，用于建立区块链中各区块寻址和查询。区块链分区表是NameNode的一部分，其索引也是全局Namespace中的一个子集。Blocknode与DataNode可以通过区块链分区表进行映射，可通过区块链分区表中的Blocknode寻址到DataNode上的存储数据块。<br><br></td>
</tr>
</tbody>
</table>
<p>&emsp;&emsp;其底层，以链式区块为单位组织数据。全网所有的交易记录都以交易单的形式存储在全网唯一的区块链中。每个区块由区块头和区块主体组成，区块主体只负责记录前一段时间内的所有交易信息，区块链的大部分功能都由区块头实现。</p>
<p><br></p>
<div align="center"><br><img src="/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/merkle.png" width="40%"><br></div> 

<p><br></p>
<table>
<thead>
<tr>
<th style="text-align:center">版本号</th>
<th style="text-align:center">标示软件及协议的相关版本信息</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">父区块哈希值</td>
<td style="text-align:center">引用的区块链中父区块头的哈希值，通过这个值每个区块才首尾相连组成了区块链，并且这个值对区块链的安全性起到了至关重要的作用</td>
</tr>
<tr>
<td style="text-align:center">Merkle根</td>
<td style="text-align:center">这个值是由区块主体中所有交易的哈希值再逐级两两哈希计算出来的一个数值，主要用于检验一笔交易是否在这个区块中存在</td>
</tr>
<tr>
<td style="text-align:center">时间戳</td>
<td style="text-align:center">记录该区块产生的时间，精确到秒</td>
</tr>
<tr>
<td style="text-align:center">难度值</td>
<td style="text-align:center">该区块相关数学题的难度目标</td>
</tr>
<tr>
<td style="text-align:center">随机数(Nonce)</td>
<td style="text-align:center">记录解密该区块相关数学题的答案的值</td>
</tr>
</tbody>
</table>
<p><br></p>
<h6 id="共识管理器-PBFT"><a href="#共识管理器-PBFT" class="headerlink" title="共识管理器(PBFT)"></a>共识管理器(PBFT)</h6><p>&emsp;&emsp;共识管理器是一个抽象概念，它定义了共识算法与其他Hyperledger组件之间的接口。共识管理器接收交易，根据算法来决定如何组织以及何时执行这些交易。交易成功执行后就会在账本上反映变化</p>
<p>关于PBFT有个简单明了的解释，可以看一下 <a href="https://yeasy.gitbooks.io/blockchain_guide/distribute_system/bft.html" target="_blank" rel="external">区块链指南</a>，这是自行组织的区块链介绍的书，里面有些有关区块结构以及merkle树知识也可以翻一翻，我就不解释了这里。</p>
<p><br></p>
<h3 id="Hyperledger-fabric-0-6与1-0"><a href="#Hyperledger-fabric-0-6与1-0" class="headerlink" title="Hyperledger fabric 0.6与1.0"></a><div align="center">Hyperledger fabric 0.6与1.0</div></h3><h4 id="Hyperledger-0-6版本架构特点"><a href="#Hyperledger-0-6版本架构特点" class="headerlink" title="Hyperledger 0.6版本架构特点"></a>Hyperledger 0.6版本架构特点</h4><p><br></p>
<div align="center"><br><img src="/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/0.6.png" width="20%"><br></div> 


<p>&emsp;&emsp;0.6版本中，每一个peer节点都承担着执行每一个transaction（包含chaincode）并且维护一个ledger和state，以及相互之间运行共识<br>    Hyperledger 0.6是目前较为稳定的版本，对应的0.6版本的运行时架构：<br><br></p>
<div align="center"><br><img src="/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/0.6arc.png" width="50%"><br></div> 

<ul>
<li>①结构简单： 应用-成员管理-Peer的三角形关系，主要业务功能全部集中于Peer节点；</li>
<li>②架构问题：不能支持私有的transaction以及保密的合约,比如如果有两个个体的交易有些信息不让其他方知道的时候，这个问题在1.0版本中的channel通道概念引进之后得到解决，同时，由于peer节点承担了太多的功能，所以带来扩展性、可维护性、安全性、业务隔离等方面的诸多问题，所以0.6版本在推出后，并没有大规模被行业使用，只是在一些零星的案例中进行业务验证</li>
</ul>
<h5 id="Hyperledger-1-0版本架构特点"><a href="#Hyperledger-1-0版本架构特点" class="headerlink" title="Hyperledger 1.0版本架构特点"></a>Hyperledger 1.0版本架构特点</h5><p><br></p>
<div align="center"><br><img src="/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/1.0arc.png" width="50%"><br></div> 


<table>
<thead>
<tr>
<th style="text-align:center">相关概念</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">channel</td>
<td style="text-align:center"><br>通道，子链，同一个peer可加入不同的channel,chaincode的操作基于channel进行。同时，channel上的peer节点同步其上chaincode的执行结果。这条子链上的内容对于通道外的结点是不可知的。并且，同一个peer结点可以加入不同channel。而Chaincode的执行是基于channel进行的，在一条channel上chaincode执行的结果会被该channel上所有的结点同步到本地Ledger中。<br><br></td>
</tr>
<tr>
<td style="text-align:center">Endorser</td>
<td style="text-align:center"><br>结点会模拟执行chaincode，这样就相当于把计算任务从consensus结点独立出来，进而减轻了consensus结点的负担，也就可以增加系统吞吐量。同时，比较重要是fabric1.0可以支持endorsement policy，即一个transaction的提交需要哪些endorser进行背书才可通过。这样整个系统的访问控制就更加灵活。<br><br></td>
</tr>
<tr>
<td style="text-align:center">Orderer</td>
<td style="text-align:center"><br>对chaincode执行结果consesus,支持solo/kafka等不同的odering策略工作就是consensus。Chaincode在endorser结点处执行之后，会被发送给orderer进行排序或者说consensus，保证transaction的顺序是一致的。然后，orderer结点会把transaction发送给相应的channel中的所有committer结点。<br><br></td>
</tr>
<tr>
<td style="text-align:center">Commiter</td>
<td style="text-align:center"><br>对chaincode的执行结果写入ledger<br><br></td>
</tr>
</tbody>
</table>
<p><br></p>
<p><br></p>
<h4 id="我所理解的-Hyperledger-fabric1-0-架构要点："><a href="#我所理解的-Hyperledger-fabric1-0-架构要点：" class="headerlink" title="我所理解的 Hyperledger fabric1.0 架构要点："></a>我所理解的 Hyperledger fabric1.0 架构要点：</h4><ol>
<li><p>分拆Peer的功能，将Blockchain的数据维护和共识服务进行分离，共识服务从Peer节点中完全分离出来，独立为Orderer节点提供共识服务</p>
</li>
<li><p>State由peer维护，ledger由orderer节点创建，由orderer节点deliver给每一个peer节点，每一个peer节点维护一个ledger的副本。</p>
</li>
<li><p>新版本的共识不再指peer之间的共识，而只是orderer节点之间的共识。每一个orderer节点连接多个peers, peer的消息只发送给orderer节点，由ordereer节点的广播机制对peer节点发来的消息进行排序广播</p>
</li>
<li><p>orderer支持多种ordering策略或者自定义的策略，官方提供了三种类型分为solo（独唱，即只有一个中央的orderer节点），kafka（卡夫卡，一种基于消息队列的更高效的消息广播机制），PBFT（拜占庭），这些是可以通过配置文件配置的</p>
</li>
<li><p>orderer支持channel（通道），一个peer节点可以连接到一个或者多个channel上，实现peer节点之间的可见性控制。</p>
</li>
</ol>
<p>&emsp;&emsp;基于新的架构，实现多通道（channel）的结构，实现了更为灵活的业务适应性（业务隔离、安全性等方面）支持更强的配置功能和策略管理功能，进一步增强系统的灵活性和适应性；</p>
<p>&emsp;&emsp;Hyperledger fabirc 1.0 版本的在0.6版本基础上，针对安全、保密、部署、维护、实际业务场景需求等方面进行了很多改进，特别是Peer节点的功能分离，给系统架构具备了支持多通道、可插拔的共识的能力，已经接近于工业应用的需求。</p>
<h4 id="Hyperledger-1-0-版本关键架构："><a href="#Hyperledger-1-0-版本关键架构：" class="headerlink" title="Hyperledger 1.0 版本关键架构："></a>Hyperledger 1.0 版本关键架构：</h4><p><br></p>
<ul>
<li><h5 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h5><p>  Fabric 1.0 的重要特征是支持多channel。</p>
</li>
</ul>
<p>&emsp;&emsp;通道是有共识服务（ordering）提供的一种通讯机制，类似于消息系统中的发布-订阅（PUB/SUB）中的topic；基于这种发布-订阅关系，将peer和orderer连接在一起，形成一个个具有保密性的通讯链路（虚拟），实现了业务隔离的要求；通道也与账本（ledger）-状态（worldstate）紧密相关</p>
<p>&emsp;&emsp;其中对于channel的理解可以类比交换机上的vlanID，通俗的讲就是如果多个peer节点连接到一个orderer节点上，假如此时peerA跟peerB有需要对其他节点不可见的消息通信，他们可以虚拟出一个单独的channel，只允许这两个节点之间的通信，从而提高了保密性。</p>
<p><br></p>
<div align="center"><br><img src="/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/channel.png" width="20%"><br></div> 



<p><br></p>
<p>&emsp;&emsp;如上图所示，共识服务与（P1、PN）、（P1、P2、P3）、（P2、P3）组成了三个相互独立的通道，加入到不同通道的Peer节点能够维护各个通道对应的账本和状态；<br>官方文档上对于通道的说明涉及到四个概念：<code>创建</code>，<code>加入</code>，<code>选举</code>，<code>通信</code></p>
<ol>
<li><p><strong>创建</strong></p>
<p> 当需要创建一个通道的时候，orderer service调用configuration system chaincode，传入anchor peer ** s , member set等参数信息创建一个通道，并生成一个包含这配置信息的创世快，我们也称之为配置块。</p>
</li>
</ol>
<ol>
<li><p><strong>加入</strong></p>
<p> 当有新的成员加入该通道时：</p>
<p> <br></p>
<div align="center"><br><img src="/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/channel_join.png" width="80%"><br></div> 


</li>
</ol>
<ol>
<li><p><strong>选举</strong></p>
<p> 一个通道中的成员节点需要选举一个leading peer来负责与orderer service通信，如果没有相对明确的选择，则通过算法来选举。（这里所说的明确的选择可以这么理解，设想一个各大银行节点的channel,那很明确的，央行应该成为该leading peer）</p>
</li>
</ol>
<ol>
<li><strong>通信</strong></li>
</ol>
<p><br></p>
<div align="center"><br><img src="/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/channel_trans.png" width="60%"><br></div> 

<p><br><br>&emsp;&emsp;在应现实世界中，不同业务场景下的参与方，例如银行、保险公司；物流企业、生产企业等实体结构；我们可以看到channel机制实际上是的Fabric建模实际业务流程的能力大大增强了，大家可以发挥想象力去找到可能的应用领域</p>
<ul>
<li><h5 id="交易流程"><a href="#交易流程" class="headerlink" title="交易流程"></a>交易流程</h5><p>  新的fabric1.0官方文档中给出下面这张流程图：</p>
<p>  <br></p>
<div align="center"><br><img src="/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/transmision.png" width="80%"><br></div> 



</li>
</ul>
<p>下面我用自己的方式解释下整个流程：</p>
<p><br></p>
<div align="center"><br><img src="/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/transmision_me.png" width="70%"><br></div> 

<p>过程详细说明：</p>
<ul>
<li><strong>步骤（1） </strong></li>
</ul>
<p>client创建并调用一个transaction，通过给定的<code>chaincodeID</code>，根据其<code>endersement policy</code>中的要求，选择一个endorser节点集合，向这些节点发出<code>PROPOSE消息</code><br>消息格式为：<code>&lt;PROPOSE, tx, [anchor]&gt;</code>, 并计算出<code>tid = HASH(PROPOSE || tx || [anchor])</code>存到内存中以便之后对收到的（3）的消息进行验证核对。<br>其中：<code>tx = &lt;clientID, chaincodeID, txpayload, timestamp, clientSig&gt;</code></p>
<p><hr><br>   clientID = 用户注册获得的用户ID标识</p>
<p>   chaincodeID = 已经部署且将要执行的链码ID</p>
<p>   txpayload = 包含交易相关操作信息</p>
<p>   timestamp = 交易创建时的时间戳</p>
<p>   clientSig = 用户的签名</p>
<hr>

<ul>
<li><p><strong>步骤（2）</strong></p>
<p>每个endorser节点收到<code>PROPOSE消息</code>后，做下面的操作：</p>
</li>
<li><p>通过endorser peer ID （<code>epID</code>）对<code>clientSig</code>进行verify的过程</p>
</li>
<li><p>调用chaincode代码对交易动作进行模拟交易，得出<code>rwset集合</code></p>
<p>  <br><br>对于readset和writeset集合说明：</p>
</li>
</ul>
<p>Peer节点解析链码访问交易记录的所有键值对，可以读可以写，它还没有更新它的状态。更具体的说：</p>
<p>VerDep是一个元组（ <code>verDep = (readset, writeset)</code> ）</p>
<p>给定请求的节点执行交易前的一个状态s:</p>
<ul>
<li>对交易读取的每一个键<code>k</code>,把<code>（k,s(k).version）</code>加入到<code>readset</code>中。</li>
<li><p>对交易修改的每一个键<code>k</code>,把<code>（k,s(k).version）</code>加入到<code>writeset</code>中。</p>
<p>  <br><br>同时，将对交易修改的每一个键<code>k</code>的新值<code>v’</code>,把<code>（k,v’）</code>加入到<code>stateUpdate</code>中，<code>v’</code>也可以是新值相对旧值<code>s(k).value</code>的增量。<br>实现中可以把<code>verDep.writeset</code>和<code>stateUpdate</code>放到一个数据结构中。</p>
</li>
</ul>
<p><br></p>
<ul>
<li><strong>步骤（3）</strong></li>
</ul>
<p>背书节点如果拒绝为其背书，则返回<code>TRANSACTION-INVALID消息</code>给<code>tx.clientID</code>，<br> 消息格式 = <code>&lt;TRANSACTION-INVALID , tid , type &gt;</code></p>
<p>这里的<code>type</code>有三种：</p>
<ul>
<li><p>1) 如果背书者获取到的状态更新和tran-proposal.stateUpdates里的不一样，它就对<code>(TRANSACTION-INVALID, tid, INCORRECT_STATE)</code>进行签名并发送给请求节点。</p>
</li>
<li><p>2) 如果背书者发现了比tran-proposal.verDeps更新的数据版本，它就对<code>(TRANSACTION-INVALID, tid, STALE_VERSION)</code>进行签名并发送给请求节点。</p>
</li>
<li><p>3) 如果背书者因为其他的一些原因（内部的背书策略、交易错误等）不想对交易进 行背书，它就对<code>(TRANSACTION-INVALID, tid, REJECTED)</code>进行签名并发送给请求节点。</p>
</li>
</ul>
<p>如果为其背书，则返回<code>TRANSACTION-ENDORSED消息</code>给<code>tx.clientID</code>,<br>消息格式 = <code>&lt;TRANSACTION-ENDORSED, tid, tran-proposal, epSig&gt;</code></p>
<p>其中tran-proposal = <code>&lt;epID, tid, chaincodeID, txContentBlob, readset, writeset&gt;</code><br>(txContenBlob = tx.txpayload, readset和writeset是如果交易结果最后能被写入<br>ledger的数据读取与写入集合)</p>
<ul>
<li><strong>步骤（4）</strong></li>
</ul>
<p>client根据收集到的<code>TRANSACTION-INVALID</code>和<code>TRANSACTION_ENDORSED</code>消息，通过<code>endorsement policy</code>判断是否达到要求，如果达不到要求则判定交易操作失败，发送消息给用户决定是否重新提交transaction，如果达到要求，则client对收集到的TRANSACTION-ENDORSE的签名，形成一个<code>endorsement</code>加上<code>trans-proposal</code>,形成一个<code>blob=(endorsement,trans-proposal)</code></p>
<p>注：我们所说的<code>ESCC</code>（endorser system chaincode）就是发生在该阶段，这里的判断依据是背书策略（endorsement policy）,关于背书策略是在链码部署的过程中设置的<br>例如：</p>
<p><br></p>
<blockquote>
<p>peer chaincode deploy -C testchainid -n mycc -p <a href="http://github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02" target="_blank" rel="external">http://github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02</a> -c ‘{“Args”:[“init”,”a”,”100”,”b”,”200”]}’ -P “AND(‘Org1.member’, ‘Org2.member’)”</p>
</blockquote>
<p>执行这条命令将在testchainid这条链上使用背书策略<code>AND(&#39;Org1.member&#39;, &#39;Org2.member&#39;)</code>.部署智能合约mycc。</p>
<p><strong>背书策略可以由两个部分组成</strong>（主体<code>principal</code>和阀门<code>theshold gate</code>）</p>
<p><br></p>
<div align="center"><br><img src="/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/org.png" width="70%"><br></div> 


<p>如上图所示，对应的背书策略可以是</p>
<p><strong>（1）主体：-P指令比如：</strong></p>
<ul>
<li>AND(‘Org1.member’, ‘Org2.member’, ‘Org3.member’) 请求三个背书节点的签名</li>
<li>OR(‘Org1.member’, ‘Org2.member’) 请求两个背书节点中的任意一个的签名</li>
<li>OR(‘Org1.member’, AND(‘Org2.member’, ‘Org3.member’)) 请求来自Org1 MSP成员或来自Org2 MSP成员和来自Org3 MSP成员的任意一个签名</li>
</ul>
<p><strong>（2）阀门：-T指令比如：</strong></p>
<ul>
<li>T(2, ‘1.1’, ‘1.2’, ‘1.3’) 请求来自’1.1’、’1.2’、’1.3’的任意2个背书节点的签名</li>
<li>T(1, ‘1.1’, T(2, ‘2.1’, ‘3.1’)) 请求来自1.1或来自2.1和3.1中的一个签名<br><br><br><em>注</em>：步骤（1） （2） （3）这个阶段是一次或多次，这涉及到<code>transaction pattern</code>概念</li>
</ul>
<p>transaction pattern分为两种</p>
<ol>
<li><p>首先client发送<propose,tx>给一个endorser节点，endorser节点通过putstate(),getstate()接口读写state的version dependencies然后返回一个anchor给client，client收到后把anchor加上形成<propose,tx,anchor>后再继续发给其他endorser节点</propose,tx,anchor></propose,tx></p>
</li>
<li><p>client一次性发送<propose,tx>给所有相关的endorser节点</propose,tx></p>
</li>
</ol>
<p><br></p>
<ul>
<li><strong>步骤（5）</strong></li>
</ul>
<p>client节点通过广播的方式发送给orderer service<code>（broadcast(blob)）</code></p>
<p><br></p>
<ul>
<li><strong>步骤（6）</strong></li>
</ul>
<p>orderer service旨在对输入的transaction做一个顺序排序的工作，为每一个channel通道创建对应的block，包含的信息有<code>seqno，prehash, blob</code></p>
<p><br></p>
<ul>
<li><strong>步骤（7）</strong></li>
</ul>
<p>orderer service将对应区块block通过<code>deliver( seqno,prehash,blob )消息</code>同时发往endorser节点和commiter节点</p>
<p>注：</p>
<p>1）seqno是一个递增的数值，且seqno相同，则prehash,blob相同</p>
<p>2）prehash = HASH( seqno || prehash || blob )</p>
<p>3）第一次的prehash是一个默认值，其后的prehash均为上一个deliver信息的哈希</p>
<p><br></p>
<ul>
<li><strong>步骤（8）</strong></li>
</ul>
<p>endorser节点收到后会有一个<code>checkpoint的过程</code>，就是我们所说的VSCC（validate system chaincode）阶段<br>下图是官方文档给出的图：</p>
<p><br></p>
<div align="center"><br><img src="/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/checkpoint.png" width="70%"><br></div> 

<p>步骤（8）的简略图如下所示：</p>
<p><br></p>
<div align="center"><br><img src="/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/checkpoint_me.png" width="50%"><br></div> 

<p><br><br>图中blob3是被判断为无效的transaction</p>
<hr>

<ul>
<li>1） endorser和commiter节点会对收到并根据背书策略被验证有效性后的block信息进行签名：<code>peerSig = Signatrue(CHECKPOINT,blocknohash,blockno,statehash)</code><br>(其中，statehash就是merkle树的根hash)</li>
</ul>
<ul>
<li>2） 然后每个节点把peerSig加上后广播给其他endorser节点<br><code>&lt;CHECKPOINT,blocknohash,blockno,statehash,peerSig&gt;</code></li>
</ul>
<ul>
<li>3） 每一个节点收到一定数量的签名后维护最后一次有效相关信息：</li>
</ul>
<p><code>lastestValidCheckpoint</code> = <blocknohasn,blockno></blocknohasn,blockno></p>
<p><code>lastestValidCecckpointProof</code> = sets of peerSig</p>
<p><code>lastestValidCheckpointedState</code> = statehash</p>
<p><code>blockno</code> = seqno</p>
<ul>
<li>4） 将有效的block接到本地维护的ledger中，这里提两个概念（一个是<code>peerLedger</code>,一个是<code>validatedLedger</code>）他们的不同点在于，前者指记录着有效交易，后者有效无效均有，所以说,最后通过checkpoint协议，是的每一个节点都维护一个有效交易的ledger.</li>
</ul>
<hr>


<ul>
<li><strong>步骤（9）</strong></li>
</ul>
<p>最后client会收到交易操作有效无效的消息通知（具体是通过<code>SDK事件</code>机制通知）。到此整个流程就结束了。</p>
<p><br><br><br><br><br><br><br></p>
<h4 id="最后的最后，自己的思考总结"><a href="#最后的最后，自己的思考总结" class="headerlink" title="最后的最后，自己的思考总结"></a><div align="center">最后的最后，自己的思考总结</div></h4><p><br></p>
<h5 id="背书节点概览图"><a href="#背书节点概览图" class="headerlink" title="背书节点概览图"></a>背书节点概览图</h5><p><br></p>
<div align="center"><br><img src="/2017/04/22/我对hyperledger-fabric-1-0-架构的理解/endorser.png" width="70%"><br></div> 

<p><br></p>
<h5 id="思考与总结"><a href="#思考与总结" class="headerlink" title="思考与总结"></a>思考与总结</h5><p><br></p>
<ul>
<li>(1) 背书节点的个数是由应用场景决定的，比如一个关于各大银行的应用，每一个银行就是一个背书节点，在特定的通道中，会选举一个leading endorser peer,在这里可以是央行。如果是一个各大商家的应用场景，则每一个商家就是一个背书节点，相应的leading背书节点可以有相应的算法选择。</li>
</ul>
<ul>
<li><p>(2)    各个背书节点之间可能有不同的交易场合，所以根据需求也可能是不同的chaincode规则，所以每一个背书节点可能有多个chaincode以及每一个chaincodeID对应的背书策略。</p>
</li>
<li><p>(3)    相应的，一个背书节点，可能有不同的通道，维护这每个通道的ledger,对于ledger的数据存储，根据实际应用进行定义，比如定义相应的数据结构体比如一个票据ticket结构体、一个资金流转circulation结构体</p>
</li>
<li><p>(4)    所以一个应用的大体的组成应该有如下结构：<br>一个membership service + 一个orderer service + 多个endorser peers</p>
</li>
<li><p>(5)    关于代码：如果同在一个通道且执行相同的规则，则配置的是相同chaincodeID的chaincode代码，如果有执行的是不同的规则，则为不同的chaincodeID的chaincode代码，通道数与chaincode数不是一一对应的，一个通道下的背书节点可以有多个chaincode,对应不同的chaincodeID</p>
</li>
<li><p>(6)    orderer service的话官方提供了solo（开发测试用），kafka, bft，这些是可以通过配置文件配置的，默认是solo,当然如果有能力开发自己的一套共识算法，则可以自定义共识插件。</p>
</li>
<li><p>(7)    一个具体的交易过程需要多少个背书节点背书？这个是根据部署chaincode的背书策略定义的。而client节点不需要连接所有的背书节点，只需要根据背书策略尽可能多的连接到背书节点上。</p>
</li>
</ul>
<p><br></p>
<p><strong>最后举一个例子说明一下在开发过程中的配置,设想一个四个背书节点的solo共识服务的节点网络:</strong></p>
<ul>
<li>A）在一台电脑上需要安装一个虚拟机平台，然后在虚拟机平台上创建四个虚拟机（比如ubuntu虚拟机）</li>
</ul>
<ul>
<li>B）设主机ip地址为192.168.1.138<br>   虚拟机peer1：192.168.1.201<br>   虚拟机peer2：192.168.1.202<br>   虚拟机peer3：192.168.1.203<br>   虚拟机peer4：192.168.1.204</li>
</ul>
<ul>
<li>C）member service运行在主机上，用docker pull 命令从docker hub上pull最新的membersrvc镜像（docker pull hyperledger/fabric-membersrvc:lastest）并本地用docker compose up运行</li>
</ul>
<ul>
<li>D）在相应的虚拟机中庸docker pull 命令从docker hub上pull最新的peer镜像（docker pull hyperledger/fabric-peer:lastest）</li>
</ul>
<ul>
<li><p>E）在相应的虚拟机中进行environment配置并设定ip及端口之间的指向，具体查看开发文档</p>
</li>
<li><p>F）编译orderer和peer的镜像（make peer-docker orderer-docker）</p>
</li>
<li><p>说明：具体的当相应的背书节点上的chaincode执行是，则会生成对应的镜像（默认的镜像命名方式为：dev+(背书节点名)+（chaincodeID）</p>
</li>
<li><p>设想一个场景就是peer1,peer2,peer4同在一个通道，而peer3不在此通道上，此时执行的交易的chaincode是peer1,peer2,peer4上的chaincode_101,则执行交易时执行docker ps会看到三个新生成的镜像，分别是dev-peer1-chaincode_101, dev-peer2-chaincode_101, dev-peer3-chaincode_101。</p>
</li>
</ul>
<p><br><br><strong>写在最后，这篇文章是基于自己在学习fabric时候的一些理解吧，当然里面如果有不准确的，欢迎交流一起学习</strong></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/区块链/" rel="tag"># 区块链</a>
          
            <a href="/tags/hyperledger/" rel="tag"># hyperledger</a>
          
            <a href="/tags/fabric/" rel="tag"># fabric</a>
          
        </div>
      

      
        
      

      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="mosen" />
          <p class="site-author-name" itemprop="name">mosen</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/huangmxsysu/" target="_blank" title="Github">
                  
                  Github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://blog.csdn.net/huangmx1995/" target="_blank" title="CSDN">
                  
                  CSDN
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://cnodejs.org/" title="Cnode" target="_blank">Cnode</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.open-open.com/" title="Open-Open" target="_blank">Open-Open</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="www.jq22.com/" title="Jq22" target="_blank">Jq22</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.v2ex.com/" title="V2ex" target="_blank">V2ex</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.codeplex.com/" title="Codeplex" target="_blank">Codeplex</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.oschina.net/" title="Oschina" target="_blank">Oschina</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料来源"><span class="nav-number">1.</span> <span class="nav-text">参考资料来源</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fabric-架构图"><span class="nav-number"></span> <span class="nav-text">fabric 架构图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Membership-Services（成员管理服务）"><span class="nav-number"></span> <span class="nav-text">Membership Services（成员管理服务）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fabric成员管理详细过程"><span class="nav-number">1.</span> <span class="nav-text">fabric成员管理详细过程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#fabric涉及到的PKI术语解释"><span class="nav-number">1.0.1.</span> <span class="nav-text">fabric涉及到的PKI术语解释</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#成员管理过程"><span class="nav-number">2.</span> <span class="nav-text">成员管理过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chaincode-Services（链码服务）"><span class="nav-number"></span> <span class="nav-text">Chaincode Services（链码服务）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Blockchain-Services（区块链服务）"><span class="nav-number"></span> <span class="nav-text">Blockchain Services（区块链服务）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#点对点（P2P）协议"><span class="nav-number">0.0.1.</span> <span class="nav-text">点对点（P2P）协议</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#分布式账本及数据存储"><span class="nav-number">0.0.2.</span> <span class="nav-text">分布式账本及数据存储</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#共识管理器-PBFT"><span class="nav-number">0.0.3.</span> <span class="nav-text">共识管理器(PBFT)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hyperledger-fabric-0-6与1-0"><span class="nav-number"></span> <span class="nav-text">Hyperledger fabric 0.6与1.0</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Hyperledger-0-6版本架构特点"><span class="nav-number">1.</span> <span class="nav-text">Hyperledger 0.6版本架构特点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Hyperledger-1-0版本架构特点"><span class="nav-number">1.1.</span> <span class="nav-text">Hyperledger 1.0版本架构特点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#我所理解的-Hyperledger-fabric1-0-架构要点："><span class="nav-number">2.</span> <span class="nav-text">我所理解的 Hyperledger fabric1.0 架构要点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hyperledger-1-0-版本关键架构："><span class="nav-number">3.</span> <span class="nav-text">Hyperledger 1.0 版本关键架构：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#通道"><span class="nav-number">3.1.</span> <span class="nav-text">通道</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#交易流程"><span class="nav-number">3.2.</span> <span class="nav-text">交易流程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最后的最后，自己的思考总结"><span class="nav-number">4.</span> <span class="nav-text">最后的最后，自己的思考总结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#背书节点概览图"><span class="nav-number">4.1.</span> <span class="nav-text">背书节点概览图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#思考与总结"><span class="nav-number">4.2.</span> <span class="nav-text">思考与总结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mosen

    <script>
     var _hmt = _hmt || [];
     (function() {
     var hm = document.createElement("script");
     hm.src = "https://hm.baidu.com/hm.js?c572d48c44b2e78e09a0c4061da035e4";
     var s = document.getElementsByTagName("script")[0]; 
     s.parentNode.insertBefore(hm, s);
    })();
</script>
   &nbsp;&nbsp;|&nbsp;&nbsp;<span><a href="/baidusitemap.xml">百度网站地图</a></span>
  
 </span>
</div>




&nbsp;&nbsp;您是第 <span id="busuanzi_value_site_uv"></span> 位访客

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
